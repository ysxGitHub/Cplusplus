/*
在 C++11 中一共提供了四种互斥锁：
    std::mutex：独占的互斥锁，不能递归使用
    std::timed_mutex：带超时的独占互斥锁，不能递归使用
    std::recursive_mutex：递归互斥锁，不带超时功能
    std::recursive_timed_mutex：带超时的递归互斥锁
*/

/*
std::mutex
    lock() 函数用于给临界区加锁，并且只能有一个线程获得锁的所有权，它有阻塞线程的作用, 函数原型如下：
    void lock();

独占互斥锁对象有两种状态：锁定和未锁定。如果互斥锁是打开的，调用 lock() 函数的线程会得到互斥锁的
    所有权，并将其上锁，其它线程再调用该函数的时候由于得不到互斥锁的所有权，就会被 lock() 函数阻塞。
    当拥有互斥锁所有权的线程将互斥锁解锁，此时被 lock() 阻塞的线程解除阻塞，抢到互斥锁所有权的线程
    加锁并继续运行，没抢到互斥锁所有权的线程继续阻塞。

除了使用 lock() 还可以使用 try_lock() 获取互斥锁的所有权并对互斥锁加锁，函数原型如下：
    bool try_lock();

二者的区别在于 try_lock() 不会阻塞线程，lock() 会阻塞线程：
    如果互斥锁是未锁定状态，得到了互斥锁所有权并加锁成功，函数返回 true
    如果互斥锁是锁定状态，无法得到互斥锁所有权加锁失败，函数返回 false

当互斥锁被锁定之后可以通过 unlock() 进行解锁，但是需要注意的是只有拥有互斥锁所有权的线程
    也就是对互斥锁上锁的线程才能将其解锁，其它线程是没有权限做这件事情的。该函数的函数原型如下：
    void unlock();

线程同步的目的是让多线程按照顺序依次执行临界区代码，这样做线程对共享资源的访问就从并行访问变为了
    线性访问，访问效率降低了，但是保证了数据的正确性。

注意：
当线程对互斥锁对象加锁，并且执行完临界区代码之后，一定要使用这个线程对互斥锁解锁，否则最终会造成
    线程的死锁。死锁之后当前应用程序中的所有线程都会被阻塞，并且阻塞无法解除，应用程序也无法继续运行。

需要强调一点：
    在所有线程的任务函数执行完毕之前，互斥锁对象是不能被析构的，一定要在程序中保证这个对象的可用性。
    互斥锁的个数和共享资源的个数相等，也就是说每一个共享资源都应该对应一个互斥锁对象。
        互斥锁对象的个数和线程的个数没有关系。
*/



/*
std::lock_guard
lock_guard 是 C++11 新增的一个模板类，使用这个类，
    可以简化互斥锁 lock() 和 unlock() 的写法，同时也更安全。

lock_guard 在使用上面提供的这个构造函数构造对象时，会自动锁定互斥量，
    而在退出作用域后进行析构时就会自动解锁，从而保证了互斥量的正确操作，
    避免忘记 unlock() 操作而导致线程死锁。lock_guard 使用了 RAII 技术，
    就是在类构造函数中分配资源，在析构函数中释放资源，保证资源出了作用域就释放。

void slow_increment(int id){
    for (int i = 0; i < 3; ++i) {
        // 使用哨兵锁管理互斥锁
        lock_guard<mutex> lock(g_num_mutex);
        ++g_num;
        cout << id << " => " << g_num << endl;
        this_thread::sleep_for(chrono::seconds(1));
    }
}
通过修改发现代码被精简了，而且不用担心因为忘记解锁而造成程序的死锁，但是这种方式也有弊端，
    在上面的示例程序中整个for循环的体都被当做了临界区，多个线程是线性的执行临界区代码的，
    因此临界区越大程序效率越低，还是需要根据实际情况选择最优的解决方案。
*/


/*
std::unique_lock
    mutex m_mutex
    unique_lock<mutex> guard(m_mutex);
    // do something 1;
    guard.unlock(); //临时解锁
    // do something 2;
    guard.lock(); // 继续上锁
    // do something 3;
    // 结束时析构 guard 会临时解锁, 最后可以不写 guard.unlock();

unique_lock 要比 lock_gurad 灵活

*/


/*
std::recursive_mutex
递归互斥锁 std::recursive_mutex 允许同一线程多次获得互斥锁，
    可以用来解决同一线程需要多次获取互斥量时死锁的问题

虽然递归互斥锁可以解决同一个互斥锁频繁获取互斥锁资源的问题，但是还是建议少用，主要原因如下：

    使用递归互斥锁的场景往往都是可以简化的，使用递归互斥锁很容易放纵复杂逻辑的产生，
        从而导致bug的产生

    递归互斥锁比非递归互斥锁效率要低一些。

    递归互斥锁虽然允许同一个线程多次获得同一个互斥锁的所有权，但最大次数并未具体说明，
        一旦超过一定的次数，就会抛出std::system错误。
*/

/*
std::timed_mutex

std::timed_mutex 是超时独占互斥锁，主要是在获取互斥锁资源时增加了超时等待功能，
    因为不知道获取锁资源需要等待多长时间，为了保证不一直等待下去，设置了一个超时时长，
    超时后线程就可以解除阻塞去做其他事情了。

std::timed_mutex 比 std::_mutex 多了两个成员函数：
    try_lock_for() 和 try_lock_until()：

    try_lock_for 函数是当线程获取不到互斥锁资源的时候，让线程阻塞一定的时间长度
    try_lock_until 函数是当线程获取不到互斥锁资源的时候，让线程阻塞到某一个指定的时间点

关于两个函数的返回值：当得到互斥锁的所有权之后，函数会马上解除阻塞，返回 true，
    如果阻塞的时长用完或者到达指定的时间点之后，函数也会解除阻塞，返回 false


*/