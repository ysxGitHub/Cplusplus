/*
在类的构造函数中，不在函数体内对成员变量赋值，而是在构造函数的花括号前面使用冒号和初始化列表赋值

效率:
用初始化列表会快一些的原因是，对于类型，它少了一次调用构造函数的过程，而在函数体中赋值则会多一次调用。而对于内置数据类型则没有差别。

如果有些成员是类，那么在进入构造函数之前，会先调用一次默认构造函数，进入构造函数后所做的事其实是一次赋值操作(对象已存在)，所以如果是在构造函数体内进行赋值的话，等于是一次默认构造加一次赋值，而初始化列表只做一次赋值操作。


当初始化一个引用成员变量时；

初始化一个const成员变量时；

当调用一个基类的构造函数，而构造函数拥有一组参数时；

当调用一个成员类的构造函数，而他拥有一组参数；

编译器会一一操作初始化列表，以适当顺序在构造函数之内安插初始化操作，并且在任何显示用户代码前。list中的项目顺序是由类中的成员声明顺序决定的，不是初始化列表中的排列顺序决定的。
*/

#include <iostream>
using namespace std;

class A {
public:
    A() {
        cout << "默认构造函数A()" << endl;
    }
    A(int a) {
        value = a;
        cout << "A(int "<<value<<")" << endl;
    }
    A(const A& a) {
        value = a.value;
        cout << "拷贝构造函数A(A& a):  "<<value << endl;
    }
    int value;
};

class B {
public:
    B() : a(1) {
        // 还会调用默认构造函数A()
        b = A(2);
    }
    A a;
    A b;
};
int main() {

    B b;
}