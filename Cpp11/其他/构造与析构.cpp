/*
在C++中，提倡不在构造函数和析构函数中调用虚函数；

构造函数和析构函数调用虚函数时都不使用动态联编，如果在构造函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数自身类型定义的版本；

因为父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化，因此调用子类的虚函数时不安全的，故而C++不会进行动态联编；

析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，然后再调用基类的析构函数。所以在调用基类的析构函数时，派生类对象的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义。
*/

#include <iostream>
using namespace std;

// 动态联编
class A
{
public:
    virtual void test1() {cout<<"A"<<endl;}//被virtual修饰的函数，被叫做虚函数，具有动态联编的特性
    void test2() {cout<<"A"<<endl;}
};
class B :public A
{
public:
    void test1() {cout<<"B"<<endl;}
    void test2() {cout<<"B"<<endl;}
};

void test()
{
    B* b = new B();
    A* a = b;
    a->test2(); // A
    b->test2(); // B
    //提问1
    a->test1(); // B
    b->test1(); // B
    //提问2

}

// 构造函数或者析构函数中可以调用虚函数吗?
// 派生类对象构造期间进入基类的构造函数时，对象类型变成了基类类型，而不是派生类类型。 同样，进入基类析构函数时，对象也是基类类型。
class C{
public:
    virtual void print(){
        cout<<"000"<<endl;
    }
    C(){
        // 不使用动态联编
        cout<<"C";
        print();
    }
    virtual ~C(){
        // 不使用动态联编
        cout<<"~C";
        print();
    }
};

class D: public C{
public:
    D(){
        // 不使用动态联编
        cout<<"D";
        print();
    }
    void print(){
        cout<<"111"<<endl;
    }
    ~D(){
        // 不使用动态联编
        cout<<"~D";
        print();
    }
};

void test2(){
    D* d = new D();
    delete d;
    cout<<"****************"<<endl;
    C* c = new D();
    delete c;
}

/*
构造函数 析构函数可否抛出异常?

2. 构造函数可以抛出异常。
3. C++标准指明析构函数不能、也不应该抛出异常。

析构函数不能抛出异常的理由:
1）如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。

2）通常异常发生时，c++的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。

3）当在某一个析构函数中会有一些可能发生异常时，那么就必须要把这种可能发生的异常完全封装在析构函数内部，决不能让它抛出函数之外
*/

int main(int argc, char const *argv[])
{
    // test();
    test2();
    return 0;
}