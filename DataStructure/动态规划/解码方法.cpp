/*
一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：

'A' -> "1"
'B' -> "2"
...
'Z' -> "26"
要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。
    例如，"11106" 可以映射为：

"AAJF" ，将消息分组为 (1 1 10 6)
"KJF" ，将消息分组为 (11 10 6)
注意，消息不能分组为  (1 11 06) ，因为 "06" 不能映射为 "F" ，
    这是由于 "6" 和 "06" 在映射中并不等价。

给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。

题目数据保证答案肯定是一个 32 位 的整数。
*/

#include<vector>
#include<iostream>
using namespace std;

// dp
/*
第一种情况是我们使用了一个字符，即 s[i] 进行解码，那么只要 s[i] != 0，
    它就可以被解码成 A∼Z 中的某个字母。由于剩余的前 i-1 个字符的解码方法数为 f_i-1,
    因此我们可以写出状态转移方程： f_i = f_i-1

第二种情况是我们使用了两个字符，即 s[i-1] 和 s[i] 进行编码。与第一种情况类似，
    s[i-1] 不能等于 0，并且 s[i-1] 和 s[i] 组成的整数必须小于等于 26，
    这样它们就可以被解码成 J∼Z 中的某个字母。由于剩余的前 i-2 个字符的解码方法数为 f_i−2,
    因此我们可以写出状态转移方程： f_i = f_i-2

上述两种情况都满足时就是 f_i = f_i-1 + f_i-2

动态规划的边界条件为：f_0 = 1 即空字符串可以有 1 种解码方法，解码出一个空字符串。
*/
int numDecodings(string s) {
    int n = s.size();
    vector<int>dp(n+1);
    dp[0] = 1;
    s = " " + s;
    for(int i=1; i<=n; i++){
        int a = s[i] - '0';
        int b = (s[i-1] - '0')*10 + a;
        if(a != 0) dp[i] = dp[i-1];
        if(b>=10 && b<=26) dp[i] += dp[i-2];
    }
    return dp[n];
}


int main(int argc, char const *argv[])
{

    return 0;
}
